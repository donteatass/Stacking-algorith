from dataclasses import dataclass, field
from typing import List, Dict, Tuple, Optional, Set, Any, Callable
import pandas as pd
import copy
from pathlib import Path
import math

@dataclass
class Sat:
   sat: str
   filled: bool
   interim: bool
   final: bool
   issue: bool
   @property
   def cleared(self) -> bool:
       return bool(self.filled and self.interim and self.final and (not self.issue))

@dataclass
class Action:
   step: int
   action: str
   location: str
   count: int
   items_top_to_bottom: List[str]
   note: str = ""

@dataclass
class StackState:
   name: str
   items: List[Sat] = field(default_factory=list)
   cap: int = 15
   def top(self) -> Optional[Sat]:
       return self.items[0] if self.items else None
   def len(self) -> int:
       return len(self.items)
   def space_left(self) -> int:
       return self.cap - len(self.items)
   def push_batch(self, sats_top_to_bottom: List[Sat]):
       self.items = list(sats_top_to_bottom) + self.items
   def pop_batch(self, k: int) -> List[Sat]:
       batch = self.items[:k]
       self.items = self.items[k:]
       return batch

   def pop_batch_bottom(self, k: int) -> List[Sat]:
       """
       Pop a batch of `k` items from the bottom of the stack.

       The returned list is ordered top-to-bottom relative to the popped segment.  For example, if
       the stack contains [top, ..., bottom] and k=3, this returns the bottom three items in the order
       [item_{-k}, item_{-k+1}, ..., item_{-1}], where item_{-1} is the original bottom of the stack.
       """
       assert k <= len(self.items), "pop_batch_bottom exceeds available items"
       batch = self.items[-k:]
       self.items = self.items[:-k]
       return batch

class LiftPlannerV1P5:
   def __init__(self, source_stacks: List[StackState], temp_stack: StackState, dest_stack: StackState,
                hand_capacity: int = 7, temp_cap: int = 15, target_ids: Optional[Set[str]] = None,
                lookahead_depth: int = 2, beam_width: int = 3, early_temp_threshold: int = 12):
       self.sources = source_stacks
       self.temp = temp_stack
       self.dest = dest_stack
       self.temp.cap = temp_cap
       self.hand: List[Sat] = []
       self.hand_capacity = hand_capacity
       self.log: List[Action] = []
       self.step_counter = 0
       self.target_ids: Set[str] = set(target_ids or set())
       self.lookahead_depth = lookahead_depth
       self.beam_width = beam_width
       self.early_temp_threshold = early_temp_threshold
       self._mode_B_active = False
                                                                                      
                                                                                       
                                                                   
       self.last_temp_drop_step: int = -1
                                                                             
                                                                                    
                                                                                  
                                                                                    
       self.just_dropped_to_temp: bool = False

   def clone(self):
       return copy.deepcopy(self)

                            
   def _record(self, action: str, location: str, count: int, items: List[Sat], note: str = ""):
       self.step_counter += 1
       self.log.append(Action(self.step_counter, action, location, count, [x.sat for x in items], note))

   def get_log_dataframe(self) -> pd.DataFrame:
       return pd.DataFrame([{"step":a.step,"action":a.action,"location":a.location,"count":a.count,
                             "items_top_to_bottom":a.items_top_to_bottom,"note":a.note} for a in self.log])

   def get_log_dataframe_compact(self) -> pd.DataFrame:
       rows = []
       carry = None                          
       for a in self.log:
           if a.action == "pick":
               if carry and carry.action == "pick" and carry.location == a.location:
                   carry.count += a.count
                   carry.items_top_to_bottom.extend(a.items_top_to_bottom)
                   if a.note and a.note not in carry.note:
                       carry.note = (carry.note + " | " + a.note).strip(" |")
               else:
                   if carry:
                       rows.append(carry)
                   carry = Action(a.step, a.action, a.location, a.count, list(a.items_top_to_bottom), a.note)
           else:
               if carry:
                   rows.append(carry); carry = None
               rows.append(a)
       if carry:
           rows.append(carry)
       for i, a in enumerate(rows, 1):
           a.step = i
       return pd.DataFrame([{"step":a.step,"action":a.action,"location":a.location,"count":a.count,
                             "items_top_to_bottom":a.items_top_to_bottom,"note":a.note} for a in rows])


   def save_log_to_csv(self, path: Path, compact: bool = True) -> None:
       """Write the action log to CSV. Uses compact format by default."""
       df = self.get_log_dataframe_compact() if compact else self.get_log_dataframe()
       path = Path(path)
       path.parent.mkdir(parents=True, exist_ok=True)
       df.to_csv(path, index=False)

   def get_summary(self) -> Dict[str, Any]:
       """
       Produce a summary of the actions taken and the final state of all stacks.

       The summary includes counts of pick and drop actions, the number of satellites in each stack,
       and the final order of satellites in the destination, source, and temporary stacks.
       Satellite lists are ordered from top (index 0) to bottom.
       """
       picks = sum(1 for a in self.log if a.action == "pick")
       drops = sum(1 for a in self.log if a.action == "drop")
       summary: Dict[str, Any] = {
           "total_actions": picks + drops,
           "pick_actions": picks,
           "drop_actions": drops,
           "dest_count": len(self.dest.items),
           "temp_count": len(self.temp.items),
           "hand_count": len(self.hand),
           "source_lengths": {s.name: len(s.items) for s in self.sources},
       }
                                                 
       summary["final_dest_top_to_bottom"] = [sat.sat for sat in self.dest.items]
       summary["final_source_stacks_top_to_bottom"] = {
           s.name: [sat.sat for sat in s.items] for s in self.sources
       }
       summary["final_temp_top_to_bottom"] = [sat.sat for sat in self.temp.items]
       return summary

                               
   def _remaining_targets(self) -> Set[str]:
       delivered = {x.sat for x in self.dest.items}
       return {t for t in self.target_ids if t not in delivered}

   def _is_remaining_target(self, sat: Optional[Sat]) -> bool:
       return bool(sat and sat.sat in self._remaining_targets())

   def _stack_has_any_remaining_target(self, stack: 'StackState') -> bool:
       rem = self._remaining_targets()
       return any(s.sat in rem for s in stack.items)

                                        
   def _score_offload_stack(self, stack: 'StackState', batch_size: int):
       """
       Compute a score for offloading a batch of TEMP items to a given stack.  Lower scores
       are better.  Penalize stacks that would require re-peeling soon by examining the depth
       of the next remaining target.  If the next target is very close to the top (e.g.,
       within a few items), avoid offloading to this stack so we don't immediately pick
       these blockers again.  Return a large penalty when the stack cannot accommodate
       the batch or when the depth is below a threshold.  Otherwise, prefer stacks with
       more free space and deeper remaining targets.
       """
                                                                                        
       if len(stack.items) + batch_size > stack.cap:
           return (10**9, 0, 0)
                                                                    
       has_any = int(self._stack_has_any_remaining_target(stack))
                                                                           
       depth = None
       rem = self._remaining_targets()
       for i, sat in enumerate(stack.items):
           if sat.sat in rem:
               depth = i
               break
                                                                                             
                                                                                              
                                                                                           
                                                                                           
                                                                   
       if depth is not None:
                                                                                             
                                                                                          
                                                                    
           threshold = min(batch_size, self.hand_capacity)
                                                                                         
                                                                                          
                                                                                      
           margin = 2
           if depth < threshold + margin:
                                                                                       
               return (10**9, 0, 0)
                                                                                           
                                                                                        
                                                 
       depth_pen = 0 if depth is None else max(0, 10 - depth)
                                                                                          
                                                                                    
                                            
       space = stack.space_left()
       return (has_any * 100 + depth_pen * 5, -space, -len(stack.items))

   def _choose_offload_stack(self, batch_size: int, exclude: Optional['StackState']=None) -> Optional['StackState']:
       """
       Choose a source stack to offload a batch of blockers into.  The stack must be
       able to accommodate the entire batch without exceeding its capacity and
       cannot expose a remaining target at the top.  Additionally, avoid stacks
       whose top is a cleared satellite or where the batch would bury an existing
       cleared satellite under seven or more blockers.  Optionally exclude a
       specific stack (typically the origin) to avoid burying the target we are
       trying to expose.

       Args:
           batch_size: Number of blockers to offload.
           exclude: A stack to exclude from consideration.

       Returns:
           The chosen StackState, or None if no valid offload site exists.
       """
       def allowed(s: 'StackState') -> bool:
                                        
           if exclude is not None and s is exclude:
               return False
                                   
           if len(s.items) + batch_size > s.cap:
               return False
                                                
           if self._is_remaining_target(s.top()):
               return False
                                                                          
           if s.top() and s.top().cleared:
               return False
                                                                            
                                                                         
           future_idx = next((i for i, sat in enumerate(s.items) if sat.cleared), None)
           if future_idx is not None and future_idx + batch_size >= 7:
               return False
           return True
       candidates = [s for s in self.sources if allowed(s)]
       if not candidates:
           return None
                                                                                     
       candidates.sort(key=lambda s: self._score_offload_stack(s, batch_size))
       return candidates[0]

   def _ensure_temp_space(self, needed: int):
       while self.temp.space_left() < needed:
                                                                              
           def safe_drop_target(s: 'StackState') -> bool:
                                                                          
               if s.space_left() <= 0:
                   return False
               if self._is_remaining_target(s.top()):
                   return False
                                                      
               if s.top() and s.top().cleared:
                   return False
                                                                                                 
               max_n = min(self.hand_capacity, len(self.temp.items), s.space_left())
               future_idx = next((i for i, sat in enumerate(s.items) if sat.cleared), None)
               if future_idx is not None and future_idx + max_n >= 7:
                   return False
               return True

           safe = [s for s in self.sources if safe_drop_target(s)]
           if not safe:
                                                                                  
               tops = [s for s in self.sources if self._is_remaining_target(s.top())]
               if not tops:
                                                                              
                   if self._mode_B_active:
                       cleared_tops = [s for s in self.sources if s.top() and s.top().cleared]
                       if cleared_tops:
                           self._pick(cleared_tops[0], 1, note="Free stack by moving top cleared to DEST")
                           self._drop(self.dest, 1, note="Drop cleared top to DEST (Mode B)")
                           continue
                                                                        
                   raise RuntimeError("Deadlock: no safe stacks and no top targets to clear.")
                                                        
               self._pick(tops[0], 1, note="Free stack top target to create safe offload site")
               self._drop(self.dest, 1, note="Clear top target to DEST")
               continue

                                                                   
           safe.sort(key=lambda s: self._score_offload_stack(s,
                                                            min(self.hand_capacity, len(self.temp.items), s.space_left())))
           target_stack = safe[0]
           move_n = min(self.hand_capacity, len(self.temp.items), target_stack.space_left())
           if move_n == 0:
               break
                                                                                      
                                                                                
                                                              
           self._pick(self.temp, move_n, note="Freeing TEMP space (early offload)")
           self._drop(target_stack, move_n, note="Return from TEMP to source (batched)")

   def maybe_early_temp_return(self):
                                                                                           
                                                                                       
                                                                                      
       if self.just_dropped_to_temp:
                                                      
           self.just_dropped_to_temp = False
           return
       if len(self.temp.items) >= self.early_temp_threshold:
           best = None
           best_stack = None
           for s in self.sources:
               if s.space_left() <= 0: continue
               if self._is_remaining_target(s.top()): continue
               score = self._score_offload_stack(s, min(self.hand_capacity, len(self.temp.items), s.space_left()))
               if best is None or score < best:
                   best = score
                   best_stack = s
           if best_stack:
               move_n = min(self.hand_capacity, len(self.temp.items), best_stack.space_left())
                                                                                      
                                                                                 
                                                              
               self._pick(self.temp, move_n, note="Proactive TEMP reduction")
               self._drop(best_stack, move_n, note="Early temp return (reduces future costs)")

                            
   def _first_remaining_target_in_stack(self, stack: 'StackState'):
       rem = self._remaining_targets()
       for idx, sat in enumerate(stack.items):
           if sat.sat in rem:
               return idx, sat
       return None

   def _candidate_stacks(self) -> List['StackState']:
       return [s for s in self.sources if self._first_remaining_target_in_stack(s) is not None]

   def _simulate_extract_from_stack(self, stack_name: str):
       sim = self.clone()
       s = next(x for x in sim.sources if x.name == stack_name)
       before = len(sim.log)
       sim._extract_one_from_stack(s)
       delta_actions = len(sim.log) - before
       return sim, delta_actions

   def _beam_choose_next_stack(self) -> 'StackState':
       cands = self._candidate_stacks()
       if not cands:
           raise RuntimeError("No candidates found.")
                                                              
       if len(cands) == 1:
           return cands[0]
                                                                             
                                                                                              
                                                                                           
                                                                                                  
       candidate_info = []                                                                                                  
       rem = self._remaining_targets()
       for s in cands:
                                                                       
           first_idx = None
           for idx, sat in enumerate(s.items):
               if sat.sat in rem:
                   first_idx = idx
                   break
           if first_idx is None:
               continue
           reachable = first_idx <= self.hand_capacity
                                                                                            
           items_after = s.items[first_idx:]
           flags = [(item.sat in rem) for item in items_after]
           segments: List[Tuple[int, int]] = []                          
           i = 0
           while i < len(flags):
               if flags[i]:
                   start = i
                   while i < len(flags) and flags[i]:
                       i += 1
                   segments.append((start, i - start))
               else:
                   i += 1
           if segments:
                                                                                 
               segments.sort(key=lambda x: (-x[1], x[0]))
               largest_start, max_run_len = segments[0]
               total_targets = sum(l for _, l in segments)
               segments_cnt = len(segments)
           else:
                                                          
               largest_start, max_run_len = 0, 1
               total_targets = 1
               segments_cnt = 1
           candidate_info.append((s, first_idx, reachable, max_run_len, total_targets, segments_cnt, largest_start))
       if not candidate_info:
                                                           
           return cands[0]
                                                                                            
                                                                
       scored: List[Tuple[float, int, int, Tuple]] = []                                              
       for info in candidate_info:
           stack_c, first_idx, reachable_c, max_run_len, total_targets, segments_cnt, largest_start = info
           idx_large = first_idx + largest_start
                                                                                                                             
           lifts_blockers = math.ceil(idx_large / self.hand_capacity)
           lifts_goods = math.ceil(max_run_len / self.hand_capacity)
           cost = (lifts_blockers + lifts_goods) * 2 / max_run_len
           scored.append((cost, -max_run_len, first_idx, info))
                                                                                         
       scored.sort(key=lambda x: (x[0], x[1], x[2]))
       best_info = scored[0][3]
       best_stack = best_info[0]
       return best_stack

   def _contiguous_top_remaining_targets(self, stack: 'StackState') -> int:
       if not self._is_remaining_target(stack.top()):
           return 0
       rem = self._remaining_targets()
       cnt = 0
       for sat in stack.items:
           if sat.sat in rem:
               cnt += 1
           else:
               break
       return cnt

   def _contiguous_top_cleared(self, stack: 'StackState') -> int:
       cnt = 0
       for sat in stack.items:
           if sat.cleared:
               cnt += 1
           else:
               break
       return cnt

   def _modeB_remaining_needed(self) -> int:
       """Estimate remaining cleared sats needed given request and availability."""
       if not getattr(self, "_mode_B_request_count", None):
           return 0
       count = self._mode_B_request_count
       delivered = len([x for x in self.dest.items if x.cleared])
       dest_set = {x.sat for x in self.dest.items}
       available_cleared = sum(
           1 for s in self.sources for sat in s.items
           if sat.cleared and sat.sat not in dest_set
       )
       target_goal = min(count, delivered + available_cleared)
       return max(0, target_goal - delivered)

   def _predict_modeB_future_lift_set(self, needed: int) -> Set[str]:
       """Predict which cleared sats are most likely to be lifted next in Mode B.
       We approximate by collecting all cleared contiguous runs across stacks, scoring
       runs by (2*(ceil(depth/hcap)+ceil(len/hcap)))/len, then taking items from the
       cheapest runs until we reach `needed` items.
       """
       if needed <= 0:
           return set()
       dest_set = {x.sat for x in self.dest.items}
       runs: List[Tuple[float,int,int,'StackState']] = []
       for s in self.sources:
                                                           
           flags = [(sat.cleared and sat.sat not in dest_set) for sat in s.items]
           i = 0
           while i < len(flags):
               if flags[i]:
                   start = i
                   while i < len(flags) and flags[i]:
                       i += 1
                   length = i - start
                   lifts_blockers = math.ceil(start / self.hand_capacity)
                   lifts_goods = math.ceil(length / self.hand_capacity)
                   actions = 2 * (lifts_blockers + lifts_goods)
                   cost = actions / length if length > 0 else float('inf')
                   runs.append((cost, start, length, s))
               else:
                   i += 1
                                             
       runs.sort(key=lambda x: (x[0], x[1]))
       selected: Set[str] = set()
       for cost, start, length, s in runs:
           for k in range(length):
               sat = s.items[start + k]
               if not sat.cleared or sat.sat in dest_set:
                   continue
               if sat.sat in selected:
                   continue
               selected.add(sat.sat)
               if len(selected) >= needed:
                   return selected
       return selected

   def _stack_has_future_modeB_lifts(self, stack: 'StackState', needed: int) -> bool:
       if needed <= 0:
           return False
       future = self._predict_modeB_future_lift_set(needed)
       for sat in stack.items:
           if sat.cleared and sat.sat in future:
               return True
       return False

   def _contiguous_remaining_from_index(self, stack: 'StackState', start: int) -> int:
       rem = self._remaining_targets()
       cnt = 0
       for sat in stack.items[start:]:
           if sat.sat in rem:
               cnt += 1
           else:
               break
       return cnt

                                            
                  
   def plan_mode_A(self):
       """
       Unified Mode A: deliver remaining target IDs using a deeper lookâahead similar
       to Mode B.  When possible, deliver contiguous top runs of targets directly.
       Otherwise, peel enough blockers (including intermediate targets) to expose
       the largest contiguous run of remaining targets in any stack.  This
       approach avoids repeatedly peeling shallow, fragmented target runs when a
       deeper run yields a lower cost per target.  It preserves the unified
       singleâpick/singleâdrop constraint used throughout the planner.
       """
       if not self.target_ids:
           raise AssertionError("Mode A requires target_ids to be provided.")
                                                           
       all_ids = {sat.sat for s in self.sources for sat in s.items}
       missing = [t for t in self.target_ids if t not in all_ids]
       if missing:
           raise AssertionError(f"Targets not found in stacks: {missing}")
                                                                          
                                                                                  
       while True:
           remaining_targets = self._remaining_targets()
           if not remaining_targets:
               break
                                                                  
           delivered = len({x.sat for x in self.dest.items if x.sat in self.target_ids})
           remaining = len(self.target_ids) - delivered
           if remaining <= 0:
               break
                                                                                               
           best_top_run = 0
           best_top_stack: Optional[StackState] = None
           for s in self.sources:
                                                      
               if not self._stack_has_any_remaining_target(s):
                   continue
                                                                                         
               run_len = self._contiguous_top_remaining_targets(s)
               if run_len > best_top_run:
                   best_top_run = run_len
                   best_top_stack = s
                                                                                
                                                                
           if best_top_run > 0:
               lifts_top = math.ceil(best_top_run / self.hand_capacity)
               cost_top = 2 * lifts_top / best_top_run
           else:
               cost_top = float('inf')
                                                                                                        
           candidates_info: List[Tuple[StackState, int, int]] = []                                     
                                                                                                
           dest_set = {x.sat for x in self.dest.items}
           rem_set = remaining_targets
           for s in self.sources:
                                                      
               if not self._stack_has_any_remaining_target(s):
                   continue
                                                                                         
               flags = [(sat.sat in rem_set) for sat in s.items]
                                                             
               try:
                   first_idx = flags.index(True)
               except ValueError:
                   continue
                                                                         
               items_after = flags[first_idx:]
                                                                                                           
               segments: List[Tuple[int, int]] = []
               i = 0
               while i < len(items_after):
                   if items_after[i]:
                       start = i
                       while i < len(items_after) and items_after[i]:
                           i += 1
                       segments.append((start, i - start))
                   else:
                       i += 1
               if not segments:
                   continue
                                                                                    
               segments.sort(key=lambda x: (-x[1], x[0]))
               largest_start, run_len_large = segments[0]
                                                                                       
               idx_large = first_idx + largest_start
                                                                                    
               if idx_large > 0:
                   candidates_info.append((s, idx_large, run_len_large))
                                                                                          
           best_large_cost = float('inf')
           best_cand: Optional[Tuple[StackState, int, int]] = None
           if candidates_info:
                                                                                                   
               cost_candidates: List[Tuple[float, int, Tuple[StackState, int, int]]] = []
               for stack_c, idx_large, run_len_large in candidates_info:
                   lifts_blockers = math.ceil(idx_large / self.hand_capacity)
                   lifts_goods = math.ceil(run_len_large / self.hand_capacity)
                   actions = 2 * (lifts_blockers + lifts_goods)
                   cost = actions / run_len_large if run_len_large > 0 else float('inf')
                   cost_candidates.append((cost, idx_large, (stack_c, idx_large, run_len_large)))
                                                                                 
               cost_candidates.sort(key=lambda x: (x[0], x[1]))
               best_large_cost, _, best_cand = cost_candidates[0]
                                                                                          
           if best_top_run > 0 and cost_top <= best_large_cost:
                                                                              
               take = min(best_top_run, self.hand_capacity, remaining)
                                                                                          
               self._pick(best_top_stack, take, note=f"Mode A unified: pick {take} target(s) from top")
               self._drop(self.dest, take, note=f"Mode A unified: deliver {take} target(s) to DEST")
                                                                    
               self.maybe_early_temp_return()
               continue
                                                                                       
           if best_cand is not None:
               stack_c, idx_large, run_len_large = best_cand
                                                                                
               peel_n = idx_large
                                                                                 
               chunk = min(self.hand_capacity, peel_n)
                                                                     
               offload = self._choose_offload_stack(chunk, exclude=stack_c)
               if offload is None:
                                                                             
                   if self.temp.space_left() < chunk:
                       self._ensure_temp_space(chunk)
                   offload = self.temp
                                                                        
               self._pick(stack_c, chunk, note="Mode A unified: peel blockers")
               self._drop(offload, chunk, note=f"Mode A unified: offload to {offload.name}")
               self.maybe_early_temp_return()
               continue
                                                                                                                          
           if not self._candidate_stacks() and self._stack_has_any_remaining_target(self.temp):
               temp_run = self._contiguous_top_remaining_targets(self.temp)
               if temp_run > 0:
                   take = min(temp_run, self.hand_capacity, remaining)
                   self._pick(self.temp, take, note="Mode A unified: deliver from TEMP")
                   self._drop(self.dest, take, note="Mode A unified: deliver from TEMP to DEST")
                   self.maybe_early_temp_return()
                   continue
               if len(self.temp.items) > 0:
                   offload_site = self._choose_offload_stack(min(self.hand_capacity, len(self.temp.items)))
                   if offload_site is not None:
                       move_n = min(self.hand_capacity, len(self.temp.items), offload_site.space_left())
                       if move_n > 0:
                           self._pick(self.temp, move_n, note="Unwind TEMP to recover candidates")
                           self._drop(offload_site, move_n, note="Unwind TEMP (to enable Mode A candidates)")
                           self.maybe_early_temp_return()
                           continue
                                                                               
                                                                                      
           if not self._remaining_targets():
               break
                                                                
           stack = self._beam_choose_next_stack()
           self._extract_one_from_stack(stack)
                                                                       
       self.return_all_temp()

   def return_all_temp(self):
       while len(self.temp.items) > 0:
           best = None; best_stack=None
           for s in self.sources:
               if s.space_left() <= 0: continue
               if self._is_remaining_target(s.top()): continue
               score = self._score_offload_stack(s, min(self.hand_capacity, len(self.temp.items), s.space_left()))
               if best is None or score < best:
                   best = score; best_stack = s
           if not best_stack:
               cand = [s for s in self.sources if s.space_left() > 0]
               if not cand:
                   raise RuntimeError("No space to return TEMP items at end.")
               best_stack = max(cand, key=lambda s: s.space_left())
           move_n = min(self.hand_capacity, len(self.temp.items), best_stack.space_left())
           self._pick(self.temp, move_n, note="Final cleanup: empty TEMP")
           self._drop(best_stack, move_n, note="Return TEMP to source")

                                                      
                                                                             
                                                                         

   def _ensure_unified_state(self):
       if not hasattr(self, 'unified_mode'):
           self.unified_mode = True
       if not hasattr(self, '_lift_in_progress'):
           self._lift_in_progress = False

   def _pick(self, stack: 'StackState', k: int, note: str = ""):
                                              
       self._ensure_unified_state()
       if getattr(self, 'unified_mode', False):
           if self._lift_in_progress:
               raise AssertionError("Unified mode: cannot perform multiple picks in a single lift.")
           if len(self.hand) != 0:
                                                                                      
               raise AssertionError("Unified mode: hand must be empty before a pick.")
           self._lift_in_progress = True
                       
       assert 1 <= k <= len(stack.items), "Pick exceeds available."
       assert len(self.hand) + k <= self.hand_capacity, "Hand over capacity."
       batch = stack.pop_batch(k)                 
       self.hand.extend(batch)
       self._record("pick", stack.name, k, batch, note)

   def _drop(self, stack: 'StackState', k: int, note: str = ""):
                                                                        
       self._ensure_unified_state()
       if getattr(self, 'unified_mode', False):
           if not self._lift_in_progress:
               raise AssertionError("Unified mode: drop without a prior pick.")
           if k != len(self.hand):
               raise AssertionError("Unified mode: must drop all lifted sats in a single drop.")
                               
       assert 1 <= k <= len(self.hand), "Drop exceeds hand content."
       batch_top_to_bottom = self.hand[-k:][::-1]
       if stack is not self.dest:
           assert len(stack.items) + k <= stack.cap, f"Drop would exceed cap of {stack.name}"
           if stack is not self.temp and self._is_remaining_target(stack.top()):
               raise AssertionError(f"Cannot drop onto {stack.name}: top is a remaining target.")
                                                                                   
                                                                                   
                                                                
       stack.push_batch(batch_top_to_bottom)
       del self.hand[-k:]
       self._record("drop", stack.name, k, batch_top_to_bottom, note)
                                      
       if getattr(self, 'unified_mode', False):
           self._lift_in_progress = False
       if stack is self.temp:
           self.just_dropped_to_temp = True

   def _extract_one_from_stack(self, stack: 'StackState') -> bool:
       """Unified override for Mode A: one pick and one drop per lift."""
                                                                             
       top_run = self._contiguous_top_remaining_targets(stack)
       if top_run > 0:
           take = min(top_run, self.hand_capacity)
           self._pick(stack, take, note=f"Pick {take} target(s) from top (unified)")
           self._drop(self.dest, take, note=f"Deliver {take} target(s) to DEST (unified)")
           self.maybe_early_temp_return()
           return True
       frt = self._first_remaining_target_in_stack(stack)
       if frt is None:
           return False
       idx, _ = frt
                                                                
       chunk = min(self.hand_capacity, idx)
       if chunk <= 0:
           return False
                                                                  
       offload = self._choose_offload_stack(chunk, exclude=stack)
       if offload is None:
           if self.temp.space_left() < chunk:
               self._ensure_temp_space(chunk)
           offload = self.temp
       self._pick(stack, chunk, note="Peel blockers (unified)")
       self._drop(offload, chunk, note=f"Offload blockers to {offload.name} (unified)")
       self.maybe_early_temp_return()
       return True
   def plan_mode_B(self, count: int = 28):
       """Unified Mode B: only one pick and one drop per lift.
       Strategy: deliver top-run cleared when present; otherwise peel blockers from the stack
       with the shallowest next-cleared target. **Preference:** when peeling, offload blockers
       directly to TEMP (if capacity can be made), only using a source stack as a last resort.
       Also stops early when fewer than `count` cleared sats exist.
       """
       self._mode_B_active = True
       self._mode_B_request_count = count
       delivered = len([x for x in self.dest.items if x.cleared])
       while True:
                                                              
           dest_set = {x.sat for x in self.dest.items}
           available_cleared = sum(
               1 for s in self.sources for sat in s.items
               if sat.cleared and sat.sat not in dest_set
           )
           remaining = min(count - delivered, available_cleared)
           if remaining <= 0:
               break

                                                                                                        
           candidates_info: List[Tuple[StackState, int, int]] = []                                     
           for s in self.sources:
                                                                 
               flags = [(sat.cleared and sat.sat not in dest_set) for sat in s.items]
                                                                                                
               segments = []                               
               i = 0
               while i < len(flags):
                   if flags[i]:
                       start = i
                       while i < len(flags) and flags[i]:
                           i += 1
                       segments.append((start, i - start))
                   else:
                       i += 1
               if not segments:
                   continue
                                                                                                   
               segments.sort(key=lambda x: (-x[1], x[0]))
               idx_large, run_len_large = segments[0]
                                                                                           
               if idx_large > 0:
                   candidates_info.append((s, idx_large, run_len_large))

                                                                 
           cost_candidates: List[Tuple[float, int, Tuple]] = []
           for cand in candidates_info:
               stack_c, idx_large, run_len_large = cand
                                                                            
               lifts_blockers = math.ceil(idx_large / self.hand_capacity)
                                                                
               lifts_goods = math.ceil(run_len_large / self.hand_capacity)
               actions = 2 * (lifts_blockers + lifts_goods)
               cost = actions / run_len_large if run_len_large > 0 else float('inf')
               cost_candidates.append((cost, idx_large, cand))
                                               
           cost_candidates.sort(key=lambda x: (x[0], x[1]))
           best_cost = cost_candidates[0][0] if cost_candidates else float('inf')

                                                                               
           best_stack = None; best_run = 0
           for s in self.sources:
               run = self._contiguous_top_cleared(s)
               if run > best_run:
                   best_run = run; best_stack = s
                                                                                           
           deliver_cost = (2 / best_run) if best_run > 0 else float('inf')

                                                                                   
           if best_run > 0 and deliver_cost <= best_cost:
               take = min(best_run, self.hand_capacity, remaining)
               self._pick(best_stack, take, note=f"Mode B unified: pick {take} cleared from top")
               self._drop(self.dest, take, note="Mode B unified: drop to DEST")
               delivered += take
               self.maybe_early_temp_return()
               continue

                                                                                     
           if not cost_candidates:
                                                                              
               break
           stack, idx, run_len = cost_candidates[0][2]
                                                                    
           chunk = min(self.hand_capacity, idx)
           if chunk <= 0:
               break


                                                                                                         
                                                               
           needed_pred = remaining                                            
           future_set = self._predict_modeB_future_lift_set(needed_pred)
                                          
           safe_candidates = []
           for s in self.sources:
               if s is stack:
                   continue
               if len(s.items) + chunk > s.cap:
                   continue
                                                                                    
                                                                                       
                                                                                    
               future_idx = next(
                   (i for i, sat in enumerate(s.items) if sat.cleared and sat.sat in future_set),
                   None,
               )
               if future_idx is not None and future_idx + chunk >= 7:
                   continue
               safe_candidates.append(s)
           offload = None
           if safe_candidates:
                                                                                               
               safe_candidates.sort(key=lambda ss: self._score_offload_stack(ss, min(self.hand_capacity, chunk)))
               offload = safe_candidates[0]
           else:
                                                         
               try:
                   if self.temp.space_left() < chunk:
                       self._ensure_temp_space(chunk)
                   if self.temp.space_left() >= chunk:
                       offload = self.temp
               except Exception:
                   offload = None
           if offload is None:
                                                                                            
               offload = self._choose_offload_stack(chunk, exclude=stack)
               if offload is None:
                                                           
                   break
           self._pick(stack, chunk, note="Mode B unified: peel blockers")
           self._drop(offload, chunk, note=f"Mode B unified: offload to {offload.name}")
           self.maybe_early_temp_return()
           delivered = len([x for x in self.dest.items if x.cleared])

       self._mode_B_active = False
       self.return_all_temp()
def _parse_bool(x: Any) -> bool:
   if isinstance(x, bool): return x
   if isinstance(x, (int, float)): return bool(x)
   s = str(x).strip().lower()
   return s in ("true","t","1","yes","y")

def read_stack_csv(path: Path, name: str) -> StackState:
   df = pd.read_csv(path)
   df.columns = [c.strip().lower() for c in df.columns]
                                                                        
                                                                
   if 'sat' not in df.columns:
                                                   
       if 'sat_id' in df.columns:
           df['sat'] = df['sat_id']
       else:
           raise ValueError(f"CSV {path} missing required column 'sat' or 'sat_id'")
   for c in ["filled","interim","final","issue"]:
       if c not in df.columns:
           raise ValueError(f"CSV {path} missing required column '{c}'")
                                                                    
   drop_cols = [c for c in df.columns if c.startswith('unnamed')]
   df = df.drop(columns=drop_cols, errors='ignore')
   items: List[Sat] = []
   for _, row in df.iterrows():
       items.append(Sat(
           sat=str(row["sat"]),
           filled=_parse_bool(row["filled"]),
           interim=_parse_bool(row["interim"]),
           final=_parse_bool(row["final"]),
           issue=_parse_bool(row["issue"]),
       ))
                                                                                                             
                                                                                                   
                                                     
   cap_size = max(15, len(items))
   return StackState(name=name, items=items, cap=cap_size)


def run_mode_A_with_failsafe_csv(planner: LiftPlannerV1P5, csv_path: Path, compact: bool = True) -> str:
   """
   Run Mode A planning and always emit a CSV of the moves seen so far, even if an exception occurs.
   Returns a status string ("success" or the exception message).
   """
   try:
       planner.plan_mode_A()
       status = "success"
   except Exception as e:
       status = f"failure: {e}"
   finally:
       try:
           planner.save_log_to_csv(csv_path, compact=compact)
       except Exception as write_err:
           status += f"; additionally failed to write CSV: {write_err}"
   return status
