{\rtf1\ansi\ansicpg1252\cocoartf2580
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 """\
run_lift_plan_from_csv.py\
==========================\
\
This script allows you to execute the satellite lift\uc0\u8209 planning\
algorithm directly on data stored in CSV files, without requiring\
SQLite.  It expects four CSV files\'97one per stack (inventory\
location)\'97each with columns ``serial_number, filled, interim, final\
and issue``.  The script reads these files into an in\uc0\u8209 memory\
structure, derives a list of satellites meeting the pass criteria\
(``filled``, ``interim`` and ``final`` all true and ``issue`` false),\
and then computes the lift plan to move exactly 28 of these\
satellites into a final (5th) stack.\
\
Usage::\
\
    python3 run_lift_plan_from_csv.py stack1.csv stack2.csv stack3.csv stack4.csv\
\
By default the script selects the first 28 satellites that meet\
the pass criteria (in alphanumeric order) for the final move.\
You can override this behaviour by editing the ``final_order`` list\
in the ``__main__`` block below to specify your own ordering.\
\
This implementation introduces a more capable lift algorithm that\
supports multi\uc0\u8209 pick operations and defers the return of temporary\
satellites until absolutely necessary.  When the lift tool has\
remaining capacity, it will:\
\
* Pick up additional ready satellites from other stacks and carry\
  them in the same lift\'97even if they aren\'92t the primary target.\
\
* Defer returning temporarily lifted satellites (those above the\
  target) until either the lift is close to capacity or the lifted\
  satellites will not be needed in the near future.  This greedy\
  lookahead allows the algorithm to keep satellites on the lift for\
  upcoming moves, minimising the total number of lifts.\
\
The algorithm still produces a sequence of operations detailing\
each lift, move and return.  See ``compute_lift_plan_from_dict``\
for more details on the behaviour.\
"""\
\
from __future__ import annotations\
\
import csv\
import sys\
from typing import Dict, List, Any, Tuple, Optional\
\
\
def load_stacks_from_csv(files: List[str]) -> Dict[int, List[Dict[str, Any]]]:\
    """Read stack definitions from a list of CSV files.\
\
    Each file should contain columns named ``serial_number``, ``filled``,\
    ``interim``, ``final`` and ``issue``.  Values in the boolean\
    columns may be any case variation of true/false.\
\
    Parameters\
    ----------\
    files : list of str\
        Paths to four CSV files corresponding to stacks 1 through 4.\
\
    Returns\
    -------\
    dict\
        A mapping from stack identifiers (1\'964) to lists of satellite\
        dictionaries.  Satellites are ordered as they appear in the\
        file; the first row becomes the top of the stack.\
    """\
    stacks: Dict[int, List[Dict[str, Any]]] = \{\}\
    for i, file_path in enumerate(files, start=1):\
        satellites: List[Dict[str, Any]] = []\
        with open(file_path, newline='') as f:\
            reader = csv.DictReader(f)\
            for row in reader:\
                # Parse boolean fields.  Any string equal to "true"\
                # (case\uc0\u8209 insensitive) is treated as True; everything else\
                # is False.\
                def parse_bool(value: str) -> bool:\
                    return str(value).strip().lower() == 'true'\
\
                satellites.append(\
                    \{\
                        'serial': row['serial_number'],\
                        'filled': parse_bool(row.get('filled', 'False')),\
                        'interim': parse_bool(row.get('interim', 'False')),\
                        'final': parse_bool(row.get('final', 'False')),\
                        'issue': parse_bool(row.get('issue', 'False')),\
                    \}\
                )\
        stacks[i] = satellites\
    return stacks\
\
\
def compute_lift_plan_from_dict(\
    stacks: Dict[int, List[Dict[str, Any]]],\
    final_order: List[str],\
    *,\
    optimize_final_group: bool = True,\
    multi_pick: bool = True,\
    lift_capacity: int = 7,\
) -> List[Dict[str, Any]]:\
    """Generate a lift plan from in\uc0\u8209 memory stack definitions.\
\
    This function mirrors the behaviour of ``compute_lift_plan`` in\
    ``satellite_manager.py`` but operates directly on a dictionary of\
    stacks rather than a SQLite database.  Each key in ``stacks``\
    (1\'964) maps to a list of satellite dictionaries ordered from top\
    (index 0) to bottom.  A new stack ``5`` will be created to hold\
    satellites as they are moved.  Unlike the simpler algorithm, this\
    implementation supports multi\uc0\u8209 pick moves and defers returning\
    temporarily lifted satellites until it makes sense to do so.\
\
    Parameters\
    ----------\
    stacks : dict\
        Mapping of stack id to a list of satellite dictionaries.\
    final_order : list of str\
        Serial numbers specifying the desired bottom\uc0\u8209 to\u8209 top order in\
        the final stack.\
    optimize_final_group : bool, optional\
        If True, the algorithm will attempt to lift the final group\
        (target plus above satellites) in one operation when possible.\
        Defaults to True.\
    multi_pick : bool, optional\
        If True, the algorithm will attempt to pick additional ready\
        satellites (those at the top of their respective stacks that\
        appear later in ``final_order`` and have not yet been\
        processed) during a lift when there is spare capacity on\
        the lift tool.  Defaults to True.\
    lift_capacity : int, optional\
        Maximum number of satellites that can be carried by the lift\
        tool at once (including both temporarily lifted and those\
        destined for the final stack).  Defaults to 7, matching\
        typical hardware constraints.\
\
    Returns\
    -------\
    list of dict\
        Sequence of operations describing the lift plan.  Each\
        operation is represented as a dictionary with keys such as\
        ``action``, ``from_stack``, ``to_stack``, ``count`` and\
        ``serials``.\
    """\
    # Copy stacks to avoid modifying the input data structure.  We\
    # create a shallow copy of each list; satellite dictionaries\
    # themselves are shared and updated in place.\
    stacks = \{sid: sat_list.copy() for sid, sat_list in stacks.items()\}\
    stacks[5] = []  # final stack\
\
    # Build a lookup for statuses so we can update statuses as we move\
    status_map: Dict[str, Dict[str, Any]] = \{\
        sat['serial']: sat for s_list in stacks.values() for sat in s_list\
    \}\
\
    operations: List[Dict[str, Any]] = []\
    # Track which serials have already been processed/moved to the final stack.\
    processed_serials: set[str] = set()\
\
    # A list of temporarily lifted groups currently held on the lift.\
    # Each entry is a dict with keys:\
    #   'stack_id': original stack from which the group was lifted\
    #   'group': list of satellite dicts (top of stack is at index 0)\
    # Groups are appended when removed from a stack and removed when\
    # returned or when all satellites have been moved to final.\
    lift_groups: List[Dict[str, Any]] = []\
\
    # Determine the remaining capacity on the lift given the current\
    # temporarily held groups and the number of satellites being carried\
    # in the current move (target and any extras).  This helper returns\
    # the number of additional satellites that can be carried.\
    def remaining_lift_capacity(current_carry: int = 0) -> int:\
        used = sum(len(g['group']) for g in lift_groups)\
        return max(lift_capacity - used - current_carry, 0)\
\
    # Helper to decide whether a temporarily held group should be\
    # returned to its original stack.  The heuristics attempt to keep\
    # groups on the lift if their top satellite appears in the near\
    # future in final_order and if there is sufficient capacity to\
    # accommodate upcoming operations.  Groups are returned if they\
    # occupy capacity that will be needed for the next lift or if the\
    # next occurrence of their top satellite is beyond a lookahead\
    # horizon.\
    def should_return_group(group: Dict[str, Any], idx_order: int) -> bool:\
        # If the group is empty there is nothing to keep.\
        if not group['group']:\
            return True\
        # Identify the serial on the top of this group (first element).\
        top_serial = group['group'][0]['serial']\
        # If the top serial has already been processed, nothing to keep.\
        if top_serial in processed_serials:\
            return True\
        # Find the position of this serial in the remaining final_order.\
        try:\
            pos = final_order.index(top_serial, idx_order)\
        except ValueError:\
            # Not present in final_order, so return it.\
            return True\
        # Determine how far in the future this satellite will be needed.\
        distance = pos - idx_order\
        # If keeping this group would exceed capacity when combined with\
        # the current target (1) and existing groups, it should be\
        # returned.  We do not include extras here since they are\
        # opportunistic and can always be skipped if capacity is tight.\
        if sum(len(g['group']) for g in lift_groups) + 1 > lift_capacity:\
            return True\
        # Lookahead heuristic: keep groups whose top satellite appears\
        # within a small window.  The window size is chosen based on\
        # available capacity; fewer free slots means we need to be more\
        # selective.  For example, with 2 free slots we will only keep\
        # satellites due within the next 2 moves.\
        free_slots = remaining_lift_capacity(current_carry=1)\
        # If there are no free slots, return.\
        if free_slots <= 0:\
            return True\
        # Keep only if distance is within free_slots; otherwise return.\
        return distance > free_slots\
\
    # Helper to return a temporarily held group back to its original\
    # stack.  This records the corresponding operation and updates\
    # ``stacks`` in place.\
    def return_group(group_entry: Dict[str, Any]):\
        g_stack_id: int = group_entry['stack_id']\
        group: List[Dict[str, Any]] = group_entry['group']\
        if not group:\
            return\
        # Reorder according to original return behaviour: place filled\
        # satellites below unfilled ones.  We treat True as 1 and False\
        # as 0 when sorting by not x['filled']; thus filled (True) are\
        # sorted before unfilled.\
        bottom_to_top = sorted(group, key=lambda x: not x['filled'])\
        top_to_bottom = list(reversed(bottom_to_top))\
        operations.append(\{\
            'action': 'return_from_temp',\
            'to_stack': g_stack_id,\
            'count': len(top_to_bottom),\
            'serials': [sat['serial'] for sat in top_to_bottom],\
        \})\
        # Place returned satellites back onto the stack.\
        stacks[g_stack_id] = top_to_bottom + stacks[g_stack_id]\
\
    # Iterate through the desired final_order with an index.  We allow\
    # manual advancement of idx_order to skip targets already processed\
    # via multi_pick or held on the lift.\
    idx_order = 0\
    while idx_order < len(final_order):\
        target_sat: Optional[Dict[str, Any]] = None  # reset target for this iteration\
        target_serial = final_order[idx_order]\
        # Skip targets already moved to final (via multi_pick or\
        # from being on the lift).\
        if target_serial in processed_serials:\
            idx_order += 1\
            continue\
\
        # Ensure status flags on the target are updated to pass criteria.\
        if target_serial not in status_map:\
            status_map[target_serial] = \{\
                'serial': target_serial,\
                'filled': True,\
                'interim': True,\
                'final': True,\
                'issue': False,\
            \}\
        else:\
            sat = status_map[target_serial]\
            sat['filled'] = True\
            sat['interim'] = True\
            sat['final'] = True\
            sat['issue'] = False\
\
        # Evaluate temporarily held groups and return any that should\
        # not be kept for the upcoming moves.  We process groups in\
        # reverse order (LIFO) to respect the lifting order when\
        # returning multiple groups.\
        # We may also need to return groups if the lift is at capacity\
        # prior to picking the current target.\
        # We build a new list of groups to keep.\
        new_lift_groups: List[Dict[str, Any]] = []\
        # We'll process from oldest to newest to allow earlier groups\
        # more opportunity to stay on the lift.\
        for group_entry in lift_groups:\
            # Decide whether to return this group.\
            if should_return_group(group_entry, idx_order):\
                return_group(group_entry)\
            else:\
                new_lift_groups.append(group_entry)\
        lift_groups = new_lift_groups\
\
        # Recompute capacity usage after potential returns.\
        used_capacity = sum(len(g['group']) for g in lift_groups)\
\
        # Attempt to locate the target satellite.  It might be in one\
        # of the active stacks or in one of the temporarily held\
        # groups.\
        found_in_stack: Optional[Tuple[int, int]] = None\
        found_in_group: Optional[Tuple[int, int]] = None\
        # Search the stacks first.\
        for s_id in sorted(stacks.keys()):\
            if s_id == 5:\
                continue  # skip final stack\
            for idx, sat in enumerate(stacks[s_id]):\
                if sat['serial'] == target_serial:\
                    found_in_stack = (s_id, idx)\
                    break\
            if found_in_stack:\
                break\
        # If not found in stacks, search in temporarily held groups.\
        if not found_in_stack:\
            for g_idx, group_entry in enumerate(lift_groups):\
                for idx, sat in enumerate(group_entry['group']):\
                    if sat['serial'] == target_serial:\
                        found_in_group = (g_idx, idx)\
                        break\
                if found_in_group:\
                    break\
\
        if found_in_group is not None and found_in_stack is None:\
            # The target is already on the lift.  Remove it from the\
            # group and move it directly to the final stack.  This\
            # frees one slot on the lift.\
            g_index, idx_in_group = found_in_group\
            group_entry = lift_groups[g_index]\
            target_sat = group_entry['group'].pop(idx_in_group)\
            operations.append(\{\
                'action': 'move_to_final',\
                'from_stack': group_entry['stack_id'],\
                'to_stack': 5,\
                'serial': target_sat['serial'],\
            \})\
            stacks[5].append(target_sat)\
            # Ensure its statuses are set to passing criteria.\
            status_map[target_sat['serial']]['filled'] = True\
            status_map[target_sat['serial']]['interim'] = True\
            status_map[target_sat['serial']]['final'] = True\
            status_map[target_sat['serial']]['issue'] = False\
            processed_serials.add(target_sat['serial'])\
            # If the group is now empty, we'll drop it from lift_groups.\
            if not group_entry['group']:\
                # Remove the group entry from the list.\
                lift_groups.pop(g_index)\
            # After moving the target, attempt multi_pick if there is\
            # remaining capacity.  We reserve one slot for the target\
            # itself when computing remaining capacity.\
            if multi_pick and remaining_lift_capacity(current_carry=1) > 0:\
                remaining_cap = remaining_lift_capacity(current_carry=1)\
                extra_moved = 0\
                next_index = idx_order + 1\
                while extra_moved < remaining_cap and next_index < len(final_order):\
                    next_serial = final_order[next_index]\
                    if next_serial in processed_serials:\
                        next_index += 1\
                        continue\
                    # Prefer picking from stacks; but also allow picking\
                    # from the top of any lift group if the serial is at\
                    # the top of that group.\
                    # First search lift_groups.\
                    found_extra: Optional[Tuple[str, int]] = None\
                    for g_i, grp_entry in enumerate(lift_groups):\
                        if grp_entry['group'] and grp_entry['group'][0]['serial'] == next_serial:\
                            found_extra = (grp_entry['stack_id'], g_i)\
                            break\
                    if found_extra:\
                        st_id, g_i = found_extra\
                        extra_sat = lift_groups[g_i]['group'].pop(0)\
                        operations.append(\{\
                            'action': 'move_to_final',\
                            'from_stack': st_id,\
                            'to_stack': 5,\
                            'serial': extra_sat['serial'],\
                        \})\
                        stacks[5].append(extra_sat)\
                        status_map[extra_sat['serial']]['filled'] = True\
                        status_map[extra_sat['serial']]['interim'] = True\
                        status_map[extra_sat['serial']]['final'] = True\
                        status_map[extra_sat['serial']]['issue'] = False\
                        processed_serials.add(extra_sat['serial'])\
                        if not lift_groups[g_i]['group']:\
                            lift_groups.pop(g_i)\
                        extra_moved += 1\
                        next_index += 1\
                        continue\
                    # Next search stacks for a ready satellite at the\
                    # top of some stack.\
                    found_stack = None\
                    for s_id2 in sorted(stacks.keys()):\
                        if s_id2 == 5:\
                            continue\
                        if stacks[s_id2] and stacks[s_id2][0]['serial'] == next_serial:\
                            found_stack = s_id2\
                            break\
                    if found_stack is None:\
                        next_index += 1\
                        continue\
                    # Remove and move this satellite\
                    extra_sat = stacks[found_stack].pop(0)\
                    operations.append(\{\
                        'action': 'move_to_final',\
                        'from_stack': found_stack,\
                        'to_stack': 5,\
                        'serial': extra_sat['serial'],\
                    \})\
                    stacks[5].append(extra_sat)\
                    # Ensure its statuses are set to passing criteria\
                    status_map[extra_sat['serial']]['filled'] = True\
                    status_map[extra_sat['serial']]['interim'] = True\
                    status_map[extra_sat['serial']]['final'] = True\
                    status_map[extra_sat['serial']]['issue'] = False\
                    processed_serials.add(extra_sat['serial'])\
                    extra_moved += 1\
                    next_index += 1\
            idx_order += 1\
            continue\
\
        # If the target is not in any lift group, we need to lift\
        # satellites above it (if any) from the stack.  We must\
        # ensure we have enough capacity to lift these satellites and\
        # still carry the target itself.\
        if found_in_stack is None:\
            # The target has been processed elsewhere, but because it\
            # wasn't found in processed_serials we shouldn't hit this.  As\
            # a safety net, skip.\
            idx_order += 1\
            continue\
\
        stack_id, target_idx = found_in_stack\
        # Determine the number of satellites above the target.\
        sats_above = target_idx\
        # If the target is at the very top of its stack and there are\
        # currently no temporarily held groups on the lift, we can\
        # opportunistically pick a batch of satellites from the same\
        # stack in one lift.  This is especially useful when a single\
        # stack has many ready satellites in order.  We include as\
        # many consecutive satellites from this stack as appear in\
        # ``final_order`` and fit within the lift's capacity.  After\
        # picking the batch we still attempt to pick additional ready\
        # satellites from other stacks if there is remaining capacity.\
        if sats_above == 0 and not lift_groups and multi_pick:\
            # Determine how many consecutive satellites from this stack\
            # appear in ``final_order`` starting with the current target.\
            batch_serials: List[str] = []\
            pos_in_stack = 0\
            # Examine ``final_order`` from the current index onward.\
            # We build a batch by matching consecutive entries in\
            # ``final_order`` with the corresponding satellites at\
            # positions in ``stacks[stack_id]``.  This allows us to\
            # remove multiple ready satellites from the same stack in a\
            # single lift when they appear sequentially in the desired\
            # order.\
            for j in range(idx_order, len(final_order)):\
                serial = final_order[j]\
                if serial in processed_serials:\
                    continue\
                # Stop if the batch has reached the capacity of the lift.\
                if len(batch_serials) >= lift_capacity:\
                    break\
                # Ensure the position exists in the stack and the serial\
                # matches the satellite at that position.\
                if (\
                    pos_in_stack < len(stacks[stack_id])\
                    and stacks[stack_id][pos_in_stack]['serial'] == serial\
                ):\
                    batch_serials.append(serial)\
                    pos_in_stack += 1\
                else:\
                    # As soon as the next serial does not match the\
                    # sequence in this stack, stop building the batch.\
                    break\
            # If the batch includes more than just the target, perform\
            # the batch lift.\
            if len(batch_serials) > 1:\
                # Remove the batch from the stack.\
                block_sats: List[Dict[str, Any]] = []\
                for serial in batch_serials:\
                    # Remove from the top of the stack (should match serial)\
                    sat = stacks[stack_id].pop(0)\
                    block_sats.append(sat)\
                # Record the lift of the entire batch.  We use the\
                # ``lift_final_group`` action to signify that all of\
                # these satellites are being lifted together for the\
                # final move.\
                operations.append(\{\
                    'action': 'lift_final_group',\
                    'from_stack': stack_id,\
                    'count': len(block_sats),\
                    'serials': [sat['serial'] for sat in block_sats],\
                \})\
                # Move each satellite in the batch to the final stack.\
                for sat in block_sats:\
                    operations.append(\{\
                        'action': 'move_to_final',\
                        'from_stack': stack_id,\
                        'to_stack': 5,\
                        'serial': sat['serial'],\
                    \})\
                    stacks[5].append(sat)\
                    # Ensure statuses are set to passing criteria\
                    status_map[sat['serial']]['filled'] = True\
                    status_map[sat['serial']]['interim'] = True\
                    status_map[sat['serial']]['final'] = True\
                    status_map[sat['serial']]['issue'] = False\
                    processed_serials.add(sat['serial'])\
                # We have now processed ``len(batch_serials)`` entries\
                # from final_order.  We will attempt to pick additional\
                # ready satellites from other stacks (not this one) if\
                # there is remaining capacity.\
                if multi_pick:\
                    # Compute remaining capacity after accounting for\
                    # the batch we just carried.  ``current_carry`` is\
                    # equal to the number of satellites in the batch.\
                    remaining_cap = remaining_lift_capacity(\
                        current_carry=len(batch_serials)\
                    )\
                    extra_moved = 0\
                    # Skip over the batch in the final_order index.\
                    next_index_for_extras = idx_order + len(batch_serials)\
                    while (\
                        extra_moved < remaining_cap\
                        and next_index_for_extras < len(final_order)\
                    ):\
                        next_serial = final_order[next_index_for_extras]\
                        if next_serial in processed_serials:\
                            next_index_for_extras += 1\
                            continue\
                        # Prefer picking from lift_groups first (there\
                        # should be none at this point).\
                        found_extra_in_group: Optional[Tuple[int, int]] = None\
                        for g_i, grp_entry in enumerate(lift_groups):\
                            if (\
                                grp_entry['group']\
                                and grp_entry['group'][0]['serial'] == next_serial\
                            ):\
                                found_extra_in_group = (g_i, 0)\
                                break\
                        if found_extra_in_group:\
                            g_i, idx_in_grp = found_extra_in_group\
                            extra_sat = lift_groups[g_i]['group'].pop(idx_in_grp)\
                            operations.append(\{\
                                'action': 'move_to_final',\
                                'from_stack': lift_groups[g_i]['stack_id'],\
                                'to_stack': 5,\
                                'serial': extra_sat['serial'],\
                            \})\
                            stacks[5].append(extra_sat)\
                            status_map[extra_sat['serial']]['filled'] = True\
                            status_map[extra_sat['serial']]['interim'] = True\
                            status_map[extra_sat['serial']]['final'] = True\
                            status_map[extra_sat['serial']]['issue'] = False\
                            processed_serials.add(extra_sat['serial'])\
                            if not lift_groups[g_i]['group']:\
                                lift_groups.pop(g_i)\
                            extra_moved += 1\
                            next_index_for_extras += 1\
                            continue\
                        # Otherwise pick from any other stack (not the\
                        # stack we just processed) if the serial is at\
                        # the top.\
                        found_stack_extra = None\
                        for s_id2 in sorted(stacks.keys()):\
                            if s_id2 == 5 or s_id2 == stack_id:\
                                continue\
                            if (\
                                stacks[s_id2]\
                                and stacks[s_id2][0]['serial'] == next_serial\
                            ):\
                                found_stack_extra = s_id2\
                                break\
                        if found_stack_extra is None:\
                            next_index_for_extras += 1\
                            continue\
                        extra_sat = stacks[found_stack_extra].pop(0)\
                        operations.append(\{\
                            'action': 'move_to_final',\
                            'from_stack': found_stack_extra,\
                            'to_stack': 5,\
                            'serial': extra_sat['serial'],\
                        \})\
                        stacks[5].append(extra_sat)\
                        status_map[extra_sat['serial']]['filled'] = True\
                        status_map[extra_sat['serial']]['interim'] = True\
                        status_map[extra_sat['serial']]['final'] = True\
                        status_map[extra_sat['serial']]['issue'] = False\
                        processed_serials.add(extra_sat['serial'])\
                        extra_moved += 1\
                        next_index_for_extras += 1\
                # Advance the main index past all processed batch entries\
                idx_order += len(batch_serials)\
                # Skip the rest of the standard removal logic for this\
                # iteration since we have handled the batch and extras.\
                continue\
        # We'll collect removed groups here to add to lift_groups.\
        newly_lifted_groups: List[Dict[str, Any]] = []\
\
        # If there are satellites above the target, remove them in\
        # groups.  We choose a group size that fits in the remaining\
        # capacity.  If optimize_final_group is enabled and the entire\
        # block from the top down to and including the target fits\
        # within the lift, we will lift the whole block.  Otherwise we\
        # lift in smaller groups until the target is at the top.\
        if sats_above > 0:\
            # The total number of satellites we need to lift including\
            # the target.\
            total_block_size = sats_above + 1\
            available_slots = remaining_lift_capacity(current_carry=1)\
            # If optimisation is enabled and we can fit the entire\
            # block on the lift, do so.\
            if optimize_final_group and total_block_size <= available_slots + 1:\
                # Remove the entire block up to and including the target.\
                block = stacks[stack_id][:total_block_size]\
                operations.append(\{\
                    'action': 'lift_final_group',\
                    'from_stack': stack_id,\
                    'count': len(block),\
                    'serials': [sat['serial'] for sat in block],\
                \})\
                # Pop the removed block from the stack.\
                stacks[stack_id] = stacks[stack_id][total_block_size:]\
                # The target is the last element in this block.\
                target_sat = block[-1]\
                # Satellites above the target remain on the lift.\
                remaining_group = block[:-1]\
                if remaining_group:\
                    newly_lifted_groups.append(\{\
                        'stack_id': stack_id,\
                        'group': remaining_group.copy(),\
                    \})\
            else:\
                # We cannot fit the whole block; lift satellites above the\
                # target in smaller groups.  We remove from the top down\
                # until the target becomes the top of the stack.\
                while sats_above > 0:\
                    # Reserve one slot for the target when computing how\
                    # many satellites can be lifted in this group.\
                    group_size = min(sats_above, remaining_lift_capacity(current_carry=1))\
                    if group_size <= 0:\
                        # We need to free up capacity before lifting.\
                        # Return the least recently lifted group to make\
                        # space.  Pop from the end of lift_groups.\
                        if lift_groups:\
                            return_group(lift_groups.pop())\
                            continue\
                        else:\
                            # If no groups to return but still no capacity,\
                            # we cannot proceed.  This should not happen\
                            # under normal circumstances given the group\
                            # sizing logic, but we guard against infinite\
                            # loops by breaking.\
                            break\
                    # Lift this group from the stack.\
                    group = stacks[stack_id][:group_size]\
                    operations.append(\{\
                        'action': 'lift_to_temp',\
                        'from_stack': stack_id,\
                        'count': len(group),\
                        'serials': [sat['serial'] for sat in group],\
                    \})\
                    stacks[stack_id] = stacks[stack_id][group_size:]\
                    sats_above -= group_size\
                    newly_lifted_groups.append(\{\
                        'stack_id': stack_id,\
                        'group': group.copy(),\
                    \})\
                    # Update available capacity for subsequent lifts (reserve a slot for the target).\
                    available_slots = remaining_lift_capacity(current_carry=1)\
\
        # Now the target should be at the top of the stack or we have\
        # already removed it via optimisation.  Remove and move it to\
        # the final stack.\
        if sats_above >= 0:\
            # If we previously optimised by lifting the entire block,\
            # target_sat is already defined.  Otherwise, pop from the\
            # stack.\
            if target_sat is None:\
                # Pop the target from the top of the stack.\
                target_sat = stacks[stack_id].pop(0)\
            operations.append(\{\
                'action': 'move_to_final',\
                'from_stack': stack_id,\
                'to_stack': 5,\
                'serial': target_sat['serial'],\
            \})\
            stacks[5].append(target_sat)\
            # Mark this serial as processed and ensure passing criteria.\
            status_map[target_sat['serial']]['filled'] = True\
            status_map[target_sat['serial']]['interim'] = True\
            status_map[target_sat['serial']]['final'] = True\
            status_map[target_sat['serial']]['issue'] = False\
            processed_serials.add(target_sat['serial'])\
\
        # Add any newly lifted groups to the list of held groups.\
        # We append rather than prepend so that return operations pop\
        # groups in the reverse order of lifting (LIFO).\
        lift_groups.extend(newly_lifted_groups)\
\
        # Attempt to pick additional ready satellites as part of this\
        # lift if multi_pick is enabled.  We compute the remaining\
        # capacity after accounting for satellites currently on the\
        # lift (including newly lifted ones) and the target itself.\
        if multi_pick:\
            # Reserve one slot for the target when computing remaining capacity\
            remaining_cap = remaining_lift_capacity(current_carry=1)\
            extra_moved = 0\
            next_index = idx_order + 1\
            while extra_moved < remaining_cap and next_index < len(final_order):\
                next_serial = final_order[next_index]\
                if next_serial in processed_serials:\
                    next_index += 1\
                    continue\
                # Attempt to pick from lift_groups first if the serial\
                # matches the top of a group.  If found, move directly\
                # to final.\
                found_extra_in_group: Optional[Tuple[int, int]] = None\
                for g_i, grp_entry in enumerate(lift_groups):\
                    if grp_entry['group'] and grp_entry['group'][0]['serial'] == next_serial:\
                        found_extra_in_group = (g_i, 0)\
                        break\
                if found_extra_in_group:\
                    g_i, idx_in_grp = found_extra_in_group\
                    extra_sat = lift_groups[g_i]['group'].pop(idx_in_grp)\
                    operations.append(\{\
                        'action': 'move_to_final',\
                        'from_stack': lift_groups[g_i]['stack_id'],\
                        'to_stack': 5,\
                        'serial': extra_sat['serial'],\
                    \})\
                    stacks[5].append(extra_sat)\
                    status_map[extra_sat['serial']]['filled'] = True\
                    status_map[extra_sat['serial']]['interim'] = True\
                    status_map[extra_sat['serial']]['final'] = True\
                    status_map[extra_sat['serial']]['issue'] = False\
                    processed_serials.add(extra_sat['serial'])\
                    if not lift_groups[g_i]['group']:\
                        lift_groups.pop(g_i)\
                    extra_moved += 1\
                    next_index += 1\
                    continue\
                # Otherwise look for the satellite at the top of any stack.\
                found_stack2 = None\
                for s_id2 in sorted(stacks.keys()):\
                    if s_id2 == 5:\
                        continue\
                    if stacks[s_id2] and stacks[s_id2][0]['serial'] == next_serial:\
                        found_stack2 = s_id2\
                        break\
                if found_stack2 is None:\
                    next_index += 1\
                    continue\
                extra_sat = stacks[found_stack2].pop(0)\
                operations.append(\{\
                    'action': 'move_to_final',\
                    'from_stack': found_stack2,\
                    'to_stack': 5,\
                    'serial': extra_sat['serial'],\
                \})\
                stacks[5].append(extra_sat)\
                status_map[extra_sat['serial']]['filled'] = True\
                status_map[extra_sat['serial']]['interim'] = True\
                status_map[extra_sat['serial']]['final'] = True\
                status_map[extra_sat['serial']]['issue'] = False\
                processed_serials.add(extra_sat['serial'])\
                extra_moved += 1\
                next_index += 1\
\
        # Advance to the next target.\
        idx_order += 1\
\
    # Once all targets have been processed, return any remaining\
    # temporarily held groups back to their original stacks.  This\
    # ensures the algorithm leaves the temporary lift empty.\
    for group_entry in lift_groups:\
        return_group(group_entry)\
\
    return operations\
\
\
def select_passing_serials(stacks: Dict[int, List[Dict[str, Any]]]) -> List[str]:\
    """Select satellites that meet the pass criteria.\
\
    A satellite passes if ``filled``, ``interim`` and ``final`` are all\
    true and ``issue`` is false.  The returned list is sorted by\
    serial number.  This function does not attempt to optimise for\
    movement efficiency \'96 use :func:`select_best_order` when you want\
    to pick a subset of satellites requiring the least repositioning.\
    """\
    passing: List[str] = []\
    for sat_list in stacks.values():\
        for sat in sat_list:\
            if sat['filled'] and sat['interim'] and sat['final'] and not sat['issue']:\
                passing.append(sat['serial'])\
    return sorted(passing)\
\
\
def select_best_order(stacks: Dict[int, List[Dict[str, Any]]], n: int) -> List[str]:\
    """Select up to ``n`` satellites that pass the criteria with minimal\
    movement cost.\
\
    Rather than ordering satellites alphanumerically, this helper\
    examines each stack and greedily selects passable satellites that\
    require the fewest obstructions to be lifted.  This prioritises\
    satellites near the top of their respective stacks and can reduce\
    the total number of lift operations when assembling the final\
    group.  The selection stops once ``n`` satellites have been\
    chosen or no more passing satellites remain.\
\
    Parameters\
    ----------\
    stacks : dict\
        Mapping of stack id to list of satellite dictionaries.  Stack\
        ``5`` (the final stack) is ignored.\
    n : int\
        Maximum number of satellites to select.\
\
    Returns\
    -------\
    list of str\
        Serial numbers of the selected satellites in the order they\
        should be moved.  The order reflects a greedy choice of\
        satellites that are easiest to access.\
    """\
    # Track which satellites have been selected so far (per stack).\
    processed: Dict[int, List[bool]] = \{\
        sid: [False] * len(sats) for sid, sats in stacks.items() if sid != 5\
    \}\
    final_order: List[str] = []\
\
    # Helper to determine if a satellite passes all criteria\
    def is_pass(sat: Dict[str, Any]) -> bool:\
        return sat['filled'] and sat['interim'] and sat['final'] and not sat['issue']\
\
    # Greedily select satellites until we reach ``n`` or run out of candidates.\
    while len(final_order) < n:\
        best_candidate: Optional[Tuple[int, int, int]] = None\
        best_cost: Optional[int] = None\
        # Iterate through the stacks in numerical order to provide a\
        # deterministic tie\uc0\u8209 break when two candidates have equal cost.\
        for sid in sorted(k for k in stacks.keys() if k != 5):\
            sat_list = stacks[sid]\
            # Find the first unprocessed satellite in this stack that passes.\
            for idx, sat in enumerate(sat_list):\
                if processed[sid][idx]:\
                    continue\
                if not is_pass(sat):\
                    # Skip non\uc0\u8209 passing satellites but still count them in the\
                    # cost for satellites deeper in the stack.\
                    continue\
                # Compute the cost as the number of unprocessed satellites\
                # above this index.  Only unprocessed satellites require\
                # lifting or moving out of the way.  Satellites already\
                # selected are considered removed.\
                cost = sum(\
                    1\
                    for i in range(idx)\
                    if not processed[sid][i]\
                )\
                if best_candidate is None or cost < best_cost:\
                    best_candidate = (sid, idx, cost)\
                    best_cost = cost\
                # Stop after finding the first passing satellite in this stack.\
                break\
        if best_candidate is None:\
            # No more passing satellites available.\
            break\
        sid, idx, _ = best_candidate\
        processed[sid][idx] = True\
        final_order.append(stacks[sid][idx]['serial'])\
    return final_order\
\
\
if __name__ == '__main__':\
    if len(sys.argv) != 5:\
        print(\
            "Usage: python3 run_lift_plan_from_csv.py stack1.csv stack2.csv stack3.csv stack4.csv"\
        )\
        sys.exit(1)\
    file_paths = sys.argv[1:]\
    stacks = load_stacks_from_csv(file_paths)\
    # Automatically select satellites that meet the pass criteria.  If\
    # fewer than 28 satellites pass, the user must adjust their CSVs\
    # or modify the final_order list below.  If more pass, the first\
    # 28 in alphanumeric order are chosen by default.\
    passing = select_passing_serials(stacks)\
    if len(passing) < 28:\
        print(f"Only \{len(passing)\} satellites meet the pass criteria; need 28.")\
        sys.exit(1)\
\
    # Automatically select a subset of satellites requiring the fewest moves.\
    # By default we choose the 28 easiest satellites to access using\
    # select_best_order.  You may override this behaviour by editing\
    # `final_order` below or by providing your own list of serials.\
    final_order = select_best_order(stacks, 28)\
\
    # Uncomment and edit the following line to specify a custom order\
    # final_order = ['S001', 'S015', ...]\
\
    print("Selected satellites for final move (bottom to top):", final_order)\
    operations = compute_lift_plan_from_dict(\
        stacks, final_order, optimize_final_group=True\
    )\
    print("\\nLift plan operations:")\
    for op in operations:\
        print(op)\
}